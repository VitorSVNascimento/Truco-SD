// base on https://raw.githubusercontent.com/vipszx/protobuf-jsonschema/master/index.js
import { GoogleTypes } from './google-types';
import { PrimitiveTypes } from './primitive-types';
class Proto2JsonSchema {
    constructor(schema, options) {
        this.protoBuffImports = [
            'google/protobuf/duration.proto',
            'google/protobuf/empty.proto',
            'google/protobuf/timestamp.proto',
            'google/protobuf/wrappers.proto',
            // https://github.com/googleapis/googleapis/tree/master/google/type
            'google/type/calendar_period.proto',
            'google/type/color.proto',
            'google/type/date.proto',
            'google/type/datetime.proto',
            'google/type/dayofweek.proto',
            'google/type/decimal.proto',
            'google/type/expr.proto',
            'google/type/fraction.proto',
            'google/type/interval.proto',
            'google/type/latlng.proto',
            'google/type/localized_text.proto',
            'google/type/money.proto',
            'google/type/month.proto',
            'google/type/phone_number.proto',
            'google/type/postal_address.proto',
            'google/type/quaternion.proto',
            'google/type/timeofday.proto',
        ];
        this.messages = {};
        this.enums = {};
        this.root = {
            definitions: {},
            used: {},
        };
        const _options = Object.assign({
            getOne: false,
            forceInline: false,
            model: undefined, // Get a model from a single object.
        }, options);
        if (_options.getOne) {
            _options.forceInline = true;
        }
        this.options = _options;
        this.schema = this.convert(schema);
    }
    convert(schema) {
        this.visit(schema, schema.package || '');
        for (const i of schema.imports) {
            if (this.protoBuffImports.indexOf(i) !== -1) {
                // Well known types, can be handled.
                continue;
            }
            throw new Error(`Protobuff imports are not supported: ${i}`);
        }
        return schema;
    }
    /**
     * Visits a schema in the tree, and assigns messages and enums to the lookup tables.
     */
    visit(schema, prefix) {
        const that = this;
        if (schema.enums) {
            schema.enums.forEach((e) => {
                e.id = prefix + (prefix ? '.' : '') + (e.id || e.name);
                that.enums[e.id] = e;
                that.visit(e, e.id);
            }, this);
        }
        if (schema.messages) {
            schema.messages.forEach((m) => {
                m.id = prefix + (prefix ? '.' : '') + (m.id || m.name);
                that.messages[m.id] = m;
                that.visit(m, m.id);
            }, this);
        }
    }
    /**
     * Top level compile method. If a type name is provided,
     * compiles just that type and its dependencies. Otherwise,
     * compiles all types in the file.
     */
    compile() {
        const that = this;
        this.root = {
            definitions: {},
            used: {},
        };
        if (this.options.getOne) {
            // Get the single defined root object
            const messagesNotUsedInOthers = this.findMessagesNotUsedInOthers();
            if (messagesNotUsedInOthers.length > 1) {
                throw new Error(`Option getOne is set but there are multple proto messages: ${messagesNotUsedInOthers.join(',')}`);
            }
            if (messagesNotUsedInOthers.length < 1) {
                throw new Error('Option getOne is set but there are no proto messages');
            }
            this.options.model = messagesNotUsedInOthers[0];
        }
        if (this.options.model) {
            this.resolve(this.options.model, '');
        }
        else {
            this.schema.messages.forEach((message) => {
                that.resolve(message.id, '');
            }, this);
            this.schema.enums.forEach((e) => {
                that.resolve(e.id, '');
            }, this);
        }
        if (this.options.model && this.options.forceInline) {
            return this.root.definitions[this.options.model];
        }
        return this.root.definitions;
    }
    /**
     * Resolves a type name at the given path in the schema tree.
     * Returns a compiled JSON schema.
     */
    resolve(type, from, base, key) {
        if (PrimitiveTypes.PRIMITIVE_TYPES[type]) {
            return PrimitiveTypes.PRIMITIVE_TYPES[type];
        }
        if (GoogleTypes.GOOGLE_API_TYPES[type]) {
            return GoogleTypes.GOOGLE_API_TYPES[type];
        }
        if (GoogleTypes.WELL_KNOWN_TYPES[type]) {
            return GoogleTypes.WELL_KNOWN_TYPES[type];
        }
        for (const id of this.possibleIds(type, from)) {
            const res = this.resolveLevel(id, base, key);
            if (res) {
                return res;
            }
        }
        throw new Error(`Could not resolve ${type}`);
    }
    possibleIds(type, from) {
        const ids = [];
        const lookup = from.split('.');
        for (let i = lookup.length; i >= 0; i--) {
            ids.push(lookup.slice(0, i).concat(type).join('.'));
        }
        return ids;
    }
    resolveLevel(id, base, key) {
        // If this type was used before, move it from inline to a reusable definition
        if (this.root.used[id] &&
            !this.root.definitions[id] &&
            !this.options.forceInline) {
            const k = this.root.used[id];
            this.root.definitions[id] = k.base[k.key];
            k.base[k.key] = this.root.definitions[id];
        }
        // If already defined, reuse
        if (this.root.definitions[id]) {
            return this.root.definitions[id];
        }
        // Compile the message or enum
        let res;
        if (this.messages[id]) {
            res = this.compileMessage(this.messages[id]);
        }
        if (this.enums[id]) {
            res = this.compileEnum(this.enums[id]);
        }
        if (res) {
            // If used, or at the root level, make a definition
            if (this.root.used[id] || !base) {
                this.root.definitions[id] = res;
                res = this.root.definitions[id];
            }
            // Mark as used if not an Enum
            if (base && key && !this.root.used[id] && !this.enums[id]) {
                this.root.used[id] = {
                    base,
                    key,
                };
            }
            return res;
        }
    }
    /**
     * Compiles and assigns a type
     */
    build(type, from, base, key) {
        const res = this.resolve(type, from, base, key);
        if (base && key) {
            base[key] = res;
        }
    }
    /**
     * Compiles a protobuf enum to JSON schema
     */
    compileEnum(enumType) {
        return {
            title: enumType.name,
            type: 'string',
            enum: Object.keys(enumType.values),
        };
    }
    /**
     * Compiles a protobuf message to JSON schema
     */
    compileMessage(message) {
        const res = {
            title: message.name,
            type: 'object',
            properties: {},
            required: [],
            tags: {},
        };
        const that = this;
        message.fields.forEach((field) => {
            if (field.map) {
                if (field.map.from !== 'string') {
                    throw new Error(`Can only use strings as map keys at ${message.id} ${field.name}`);
                }
                // eslint-disable-next-line  @typescript-eslint/no-non-null-assertion
                const f = (res.properties[field.name] = {
                    type: 'object',
                    additionalProperties: false,
                });
                that.build(field.map.to, message.id, f, 'additionalProperties');
            }
            else if (field.repeated) {
                // eslint-disable-next-line  @typescript-eslint/no-non-null-assertion
                const f = (res.properties[field.name] = {
                    type: 'array',
                    items: [],
                });
                that.build(field.type, message.id, f, 'items');
            }
            else {
                that.build(field.type, message.id, res.properties, field.name);
            }
            if (field.required) {
                // eslint-disable-next-line  @typescript-eslint/no-non-null-assertion
                res.required.push(field.name);
            }
            if (field.tag) {
                res.tags[field.name] = field.tag;
            }
        }, this);
        return res;
    }
    findMessagesNotUsedInOthers() {
        const complexTypes = [];
        for (const message of this.schema.messages) {
            complexTypes.push(message.id);
        }
        const messagesUsedInOtherMessages = [];
        for (const message of this.schema.messages) {
            for (const field of message.fields) {
                for (const typePath of this.possibleIds(field.type, message.id)) {
                    if (complexTypes.indexOf(typePath) !== -1 && // Is complex type and not a sub message
                        typePath !== message.id // filter recursions with own type
                    ) {
                        messagesUsedInOtherMessages.push(typePath);
                    }
                }
            }
        }
        const messagesNotUsedInOtherMessages = [];
        for (const message of this.schema.messages) {
            if (messagesUsedInOtherMessages.indexOf(message.id) === -1) {
                messagesNotUsedInOtherMessages.push(message.id);
            }
        }
        return messagesNotUsedInOtherMessages;
    }
}
export function protoj2jsonSchema(protoSchema, options) {
    const compiler = new Proto2JsonSchema(protoSchema, options);
    return compiler.compile();
}
